#!/usr/bin/env ruby

require "optparse"
require "ostruct"

$:.unshift File.expand_path("../lib", __dir__)
require "machine"
require "plugboard"
require "rotor"
require "reflector"

options = OpenStruct.new
options.patches = []

OptionParser.new do |opts|
  opts.banner = "Usage: enigma [options] plaintext-or-cyphertext"

  opts.on "-rROTORS", "--rotors ROTORS", Array, "[required] Comma-separated list of rotors to use (some combination of I, II and III)" do |rotors|
    options.rotors = rotors
  end

  opts.on "-sPOSITIONS", "--start POSITIONS", Array, "[required] Comma-separated list of start rotor positions (eg A,B,C)" do |positions|
    options.positions = positions
  end

  opts.on "-gSETTINGS", "--ring SETTINGS", Array, "Comma-separated list of ring settings (eg 5,10,15) - defaults to (1,1,1)" do |ring_settings|
    options.ring_settings = ring_settings.map(&:to_i)
  end

  opts.on "-pPAIRS", "--patch PAIRS", Array, "Comma-separated list of plugboard patches (eg AB,CD)" do |patches|
    options.patches = patches
  end

  opts.on "-h", "--help", "Print this help" do
    puts opts
    exit
  end
end.parse! ARGV

abort "Missing rotors option (run with -h for help)" unless options.rotors
abort "Missing start option (run with -h for help)" unless options.positions

options.ring_settings ||= [1] * options.rotors.size

ROTORS = {
  "I" => Rotor.new("EKMFLGDQVZNTOWYHXUSPAIBRCJ", "Q"),
  "II" => Rotor.new("AJDKSIRUXBLHWTMCQGZNPYFVOE", "E"),
  "III" => Rotor.new("BDFHJLCPRTXVZNYEIWGAKMUSQO", "V"),
}

plugboard = Plugboard.new
options.patches.each {|patch| plugboard.patch(*patch.chars) }

rotors = ROTORS.values_at(*options.rotors)
rotors.zip(options.ring_settings).each {|(rotor, setting)| rotor.ring_setting = setting }
rotors.zip(options.positions).each {|(rotor, position)| rotor.position = position }

reflector = Reflector.new "YRUHQSLDPXNGOKMIEBFZCWVJAT"

machine = Machine.new plugboard: plugboard, rotors: rotors, reflector: reflector

puts ARGV.join.upcase.tr("^A-Z", "").chars.map {|c| machine.encrypt c }.each_slice(5).map(&:join).join " "

